return(sqrt((X2^2)/N))
}
X21toR <- function(X2, N){
return(sqrt((X2^2)/(X2^2+ N)))
}
DtoR <- function(d){
return(sqrt((d^2)/(4+d^2)))
}
ZtoR(2.02, 14)
ZtoR(2.02, 14)
ZtoR(2.07, 14)
ZtoR(2.07, 9)
ZtoR(-2.7, 10)
DtoR(-.306)
DtoR(-.308)
DtoR(-.246)
TautoR <- function(tau){
return(sin(.5*pi*tau))
}
TautoR(.285)
TautoR(.143)
TautoR(-.331)
TautoR(-.025)
DtoR(-.316)
DtoR(.358)
Fn1toR(5.8, 32)
Fn1toR(3.9, 32)
UtoR <-function(U){
return(1/U)
}
UtoR(29)
UtoR <-function(U, N1, N2){
return((U-((N1*N1)/2))/(sqrt((N1*N2*((N1+N2)+1))/12)))
}
UtoR(29,17,7)
UtoR(2.9,17,7)
UtoR(29,17,7)
n1 <- 17
n2 <- 7
sqrt((N1*N2*(N1+N2+1))/12)
N1 <- 17
N2 <- 7
sqrt((N1*N2*(N1+N2+1))/12)
N1*N2*(N1+N2+1)
(N1*N2*(N1+N2+1))/12)
(N1*N2*(N1+N2+1))/12
sqrt((N1*N2*(N1+N2+1))/12))
sqrt((N1*N2*(N1+N2+1))/12)
(N1*N1)/2)
UtoR <-function(U, N1, N2){
return((U-((N1*N2)/2))/(sqrt((N1*N2*(N1+N2+1))/12)))
}
UtoR(29,17,7)
(N1*N2)/2
29-59.5
-30.5/15.74
UtoR(29,17,7)
UtoZ <-function(U, N1, N2){
return((U-((N1*N2)/2))/(sqrt((N1*N2*(N1+N2+1))/12)))
}
UtoR(29,17,7)
ZtoR(UtoR(29,17,7), (17+7))
ZtoR(-1.685, (17+7))
Fn1toR(3.9, 29)
Fn1toR(5.8, 29)
Fn1toR(3.9, 6)
Fn1toR(3.9, 7)
Fn1toR(6.4, 39)
Fn1toR(6.4, 38)
Fn1toR(9.2, 19)
Fn1toR(5.21, 36)
Fn1toR(6.7, 79)
Fn1toR(6.7, 80)
TtoR(3.209, 13)
TtoR(-.15, 18)
TtoR(-2.21, 18)
X21toR <- function(X2, N){
return(sqrt((X2^2)/N))
}
X22toR <- function(X2, N){
return(sqrt((X2^2)/(X2^2+ N)))
}
X21toR(4.6, 61)
X22toR(4.6, 63)
X22toR(.4, 62)
ZtoR(-1.39, 19
DtoR(.358)
TautoR(-.025)
Fn1toR(6.7, 80)
ZtoR(UtoR(29,17,7), (17+7))
TtoR(-2.21, 18)
UtoZ(29,17,7)
ZtoR(UtoZ(29,17,7), (17+7))
TtoR <-function(t, df) {
return(sqrt((t^2)/(t^2+df)))
}
ZtoR <- function(z,N){
return(sqrt((z^2)/(z^2+N)))
}
Fn1toR <- function(f, dfd){
return(sqrt((f)/(f+dfd)))
}
Fn2toR <- function(f, dfd, dfn){
return(sqrt((dfn*f)/((dfn*f)+dfd)))
}
X21toR <- function(X2, N){
return(sqrt((X2^2)/N))
}
X22toR <- function(X2, N){
return(sqrt((X2^2)/(X2^2+ N)))
}
DtoR <- function(d){
return(sqrt((d^2)/(4+d^2)))
}
TautoR <- function(tau){
return(sin(.5*pi*tau))
}
UtoZ <-function(U, N1, N2){
return((U-((N1*N2)/2))/(sqrt((N1*N2*(N1+N2+1))/12)))
}
ZtoR(-2.7, 10)
DtoR(-.308)
DtoR(-.316)
X21toR(4.6, 72)
X21toR(4.6, 76)
Fn1toR(6.4, 38)
Fn1toR(5.8, 29)
Fn1toR(3.9, 6)
Fn1toR(9.2, 19)
DtoR(.246)
Fn1toR(5.21, 34)
TtoR(3.209, 13)
TautoR(.285)
TautoR(.143)
TautoR(-.331)
TautoR(-.025)
TautoR(.002)
Fn1toR(9.2, 19)
DtoR(-.306)
TtoR(-.4, 6)
ZtoR(2.02, 9)
ZtoR(2.07, 14)
ZtoR(UtoZ(29,17,7), (17+7))
install.packages(c("caTools", "colorspace", "devtools", "digest", "evaluate", "formatR", "gtable", "hexbin", "highr", "htmltools", "httr", "jsonlite", "knitr", "manipulate", "mapproj", "maps", "markdown", "memoise", "mime", "munsell", "plyr", "RColorBrewer", "Rcpp", "RCurl", "reshape2", "rmarkdown", "roxygen2", "rstudioapi", "testthat"))
sessionInfo()
install.packages("phytools")
sessionInfo()
install.packages("phytools")
install.packages("phytools")
sessionInfo()
install.packages("phytools")
package_version(phytools)
rm(list = objects())
rm(list = objects())
#install.packages("maps")
#install.packages("ape")
#install.packages("phytools")
#Libraries
library(maps)
library(ape)
library(phytools)
sessionInfo()
install.packages("phytools")
library(devtools)
install_github("liamrevell/phytools")
install.packages("phytools")
session_info()
library(phytools)
#install.packages("maps")
#install.packages("ape")
#install.packages("phytools")
#Libraries
library(maps)
library(ape)
library(phytools)
session_info()
rm(list = objects())
library(devtools)
install_github("liamrevell/phytools")
nicole [10:29]
library(devtools)
install_github("liamrevell/phytools")
install_github("liamrevell/phytools")
install_github()
sessionInfo()
installed.packages()
install.packages("devtools")
library(devtools)
install_github("liamrevell/phytools")
rm(list = objects())
#install.packages("maps")
#install.packages("ape")
#install.packages("phytools")
#Libraries
library(maps)
library(ape)
library(phytools)
#Question 1: (easy)
###A) Multiply column 2 and 41 in TestData by 2.  What happens to the NAs?
TestData[c(2, 41)] <- TestData[c(2, 41)]*2
TestData<-read.table("abigailtestdata.txt", sep = '\t',header = TRUE, fileEncoding = "UTF-8")
getwd()
#Coding 102!!!
setwd(C:/Users/Kara/Documents/R/BirbClass)
TestData<-read.table("abigailtestdata.txt", sep = '\t',header = TRUE, fileEncoding = "UTF-8")
#Coding 102!!!
setwd("C:/Users/Kara/Documents/R/BirbClass")
TestData<-read.table("abigailtestdata.txt", sep = '\t',header = TRUE, fileEncoding = "UTF-8")
#Question 1: (easy)
###A) Multiply column 2 and 41 in TestData by 2.  What happens to the NAs?
TestData[c(2, 41)] <- TestData[c(2, 41)]*2
TestData[c(2, 41)]
TestData
###b) Test which columns in TestData are numeric. Return results as a boolean Vector.
###Hint: It would be prudent to create a vector before you try to index it.
#You usually can't index a variable that doesn't exist
TF <- rep(NA, length(TestData))
for(i in seq_along(TestData)){
TF[i] <- is.numeric(TestData[,i])
}
print(TF)
###c) Mutiply all numeric rows by 2.
TestData[,TF] <- TestData[,TF]*2
TestData
###d) Make a new dataframe from columns 1 and 2.  Prove it is a dataframe.
#Coerce this Dataframe into being a new matrix.  Prove it is a matrix.
#Coerce this matrix into being a new vector.  Prove it is a vector.
#Coerce this vector back into being a dataframe.
#Brefily explain how your final dataframe is different from the original.
#There are two critical features.
NewDataFrame <- TestData[,1:2]
NewDataFrame
class(NewDataFrame)
NewMatrix <- as.matrix(NewDataFrame)
class(NewMatrix)
NewVector <- as.vector(NewMatrix)
class(NewVector)
DataFrameFinal <- as.data.frame(NewVector)
DataFrameFinal
class(DataFrameFinal[,1])
###e) Write code that prints "even" if tested against an even number (x=4) and "odd"
#when tested against an odd number (x=7)
#Hint: google "modulus" if you don't know what that means.
x <- 4 #or 7
if(x%%2 == 1){
print("odd")
}else{print("even")}
###e) Write code that prints "even" if tested against an even number (x=4) and "odd"
#when tested against an odd number (x=7)
#Hint: google "modulus" if you don't know what that means.
x <- 7 #or 7
if(x%%2 == 1){
print("odd")
}else{print("even")}
#Question 2: (medium)
###a) Using the final dataframe from 1d, coerce that dataframe into being
#identicle to the first dataframe from 1d.  Reassinging the final dataframe as the
#original one or the data from TestData is cheating. :)
#Hint: there is factor weirdness going on.  I will explain it next time
#For now, know that as.character() will serve you well here
DataFrameFinal[,2] <- DataFrameFinal[26:50,1]
DataFrameFinal
DataFrameFinal <- DataFrameFinal[1:25,]
DataFrameFinal
DataFrameFinal[,2] <- as.numeric(as.character(DataFrameFinal[,2]))
DataFrameFinal[,2]
class(DataFrameFinal[,2])
names(DataFrameFinal) <- c("FileName", "avg_note_duration.ms.")
DataFrameFinal
###b) Using the boolean vector from 1b, write a piece of code that will print "numeric"
#if the vector is true.  Otherwise, print the class of the coorsponding column in TestData
###Hint: If you print data.frame, you haven't quite solved the problem
for(i in seq_along(TestData[,])){
if(TF[i] == TRUE){
print("numeric")
}else{
print(class(TestData[,i]))
}
}
#Pull up your notes from coding 101!  You will remember that I taught you about the
#components of functions and how to write them.  Let's do that!
#A)
###i) start by writing out the bare bones of your function called TestRun.
###ii) Create two arguments: data and something
###iii) Make the main code print something
###iv) Test your function with data = TestData and something = "Success!"
TestRun <- function(data, something){
print(something)
}
TestRun(data = TestData, something = "Success!")
perfect <- which(data$sequential_repetition == 1)
#B)
###i) Copy the function from above.  We're going to modify it.
###ii) We want our function to examine whether the number of notes
#data in TestData changes based on the sequential repetition.
#break the data into two groups, based on whether they have perfect
# repetition (1) or imperfect repetition (<1)
###iii) Use t.test() to compare the groups and store the output
###iv) If there was a significant difference between the two groups,
#print something.  Otherwise, plot the data with perfect repetition
#in blue and imperfect repetition in black.
TestRun <- function(data, something){
perfect <- which(data$sequential_repetition == 1)
PerfectSeq <- data.frame(data$sequential_repetition[perfect],
data$num_notes[perfect])
ImPerfectSeq <- data.frame(data$sequential_repetition[-perfect],
data$num_notes[-perfect])
output <- t.test(PerfectSeq, ImPerfectSeq)
if(output$p.value < .05){
print(something)
}else{
colors <- rep("black", length(data$sequential_repetition))
colors[perfect] <- "blue"
plot(data$sequential_repetition,data$num_notes, col=colors)
}
}
TestRun(TestData, "significant!")
#B)
###i) Copy the function from above.  We're going to modify it.
###ii) We want our function to examine whether the number of notes
#data in TestData changes based on the sequential repetition.
#break the data into two groups, based on whether they have perfect
# repetition (1) or imperfect repetition (<1)
###iii) Use t.test() to compare the groups and store the output
###iv) If there was a significant difference between the two groups,
#print something.  Otherwise, plot the data with perfect repetition
#in blue and imperfect repetition in black.
TestRun <- function(data, something){
perfect <- which(data$sequential_repetition == 1)
PerfectSeq <- data.frame(data$sequential_repetition[perfect],
data$num_notes[perfect])
ImPerfectSeq <- data.frame(data$sequential_repetition[-perfect],
data$num_notes[-perfect])
output <- t.test(PerfectSeq, ImPerfectSeq)
if(output$p.value < .05){
print(something)
}else{
colors <- rep("black", length(data$sequential_repetition))
colors[perfect] <- "blue"
plot(data$sequential_repetition,data$num_notes, col=colors)
}
}
TestRun(TestData, "significant!")
#B)
###i) Copy the function from above.  We're going to modify it.
###ii) We want our function to examine whether the number of notes
#data in TestData changes based on the sequential repetition.
#break the data into two groups, based on whether they have perfect
# repetition (1) or imperfect repetition (<1)
###iii) Use t.test() to compare the groups and store the output
###iv) If there was a significant difference between the two groups,
#print something.  Otherwise, plot the data with perfect repetition
#in blue and imperfect repetition in black.
data <- TestData
perfect <- which(data$sequential_repetition == 1)
PerfectSeq <- data.frame(data$sequential_repetition[perfect],
data$num_notes[perfect])
ImPerfectSeq <- data.frame(data$sequential_repetition[-perfect],
data$num_notes[-perfect])
output <- t.test(PerfectSeq, ImPerfectSeq)
ImPerfectSeq
ImPerfectSeq
PerfectSeq
perfect
data$sequential_repetition
TestData<-read.table("abigailtestdata.txt", sep = '\t',header = TRUE, fileEncoding = "UTF-8")
###i) Copy the function from above.  We're going to modify it.
###ii) We want our function to examine whether the number of notes
#data in TestData changes based on the sequential repetition.
#break the data into two groups, based on whether they have perfect
# repetition (1) or imperfect repetition (<1)
###iii) Use t.test() to compare the groups and store the output
###iv) If there was a significant difference between the two groups,
#print something.  Otherwise, plot the data with perfect repetition
#in blue and imperfect repetition in black.
###HINT: RELOAD TESTDATA!  You changed it in the problems above!!
TestRun <- function(data, something){
perfect <- which(data$sequential_repetition == 1)
PerfectSeq <- data.frame(data$sequential_repetition[perfect],
data$num_notes[perfect])
ImPerfectSeq <- data.frame(data$sequential_repetition[-perfect],
data$num_notes[-perfect])
output <- t.test(PerfectSeq, ImPerfectSeq)
if(output$p.value < .05){
print(something)
}else{
colors <- rep("black", length(data$sequential_repetition))
colors[perfect] <- "blue"
plot(data$sequential_repetition,data$num_notes, col=colors)
}
}
TestRun(TestData, "significant!")
#C) Test TestData2, TestData3, and TestData4 against your code.
#If any of them fail, go back and modify your function.  Full
#Success means that all of the TestDatas work!
TestData2 <- data.frame(c(rep(1, 13), rep(.5, 12)), c(rep(50, 13), rep(100, 12)))
names(TestData2) <- c("sequential_repetition", "num_notes")
names(TestData2) <- c("sequential_repetition", "num_notes")
#C) Test TestData2, TestData3, and TestData4 against your code.
#If any of them fail, go back and modify your function.  Full
#Success means that all of the TestDatas work!
TestData2 <- data.frame(c(rep(1, 13), rep(.5, 12)), c(rep(50, 13), rep(100, 12)))
names(TestData2) <- c("sequential_repetition", "num_notes")
TestData3 <- data.frame(c(rep(1, 12), rep(.5, 12)), c(rep(50, 12), rep(50, 12)))
names(TestData3) <- c("sequential_repetition", "num_notes")
TestData4 <- data.frame(c(rep(75, 12), rep(74, 12)),c(rep(1, 12), rep(.5, 12)))
names(TestData4) <- c( "num_notes", "sequential_repetition")
dev.off()
getwd()
TestRun(TestData2, "significant!")
TestRun(TestData3, "significant!")
TestRun(TestData4, "significant!")
TestRun(TestData3, "significant!")
TestRun(TestData4, "significant!")
#Coding 103!
setwd("C:/Users/Kara/Documents/r/Birbclass")
TestData<-read.table("abigailtestdata.txt", sep = '\t',header = TRUE, fileEncoding = "UTF-8")
MetaData<-read.csv('TestMetaData.csv')
#Factors are excellent for categorical data.
BirdColor <- rep("Blue", 46)
BirdColor[c(2,7,10:20, 35, 37)] <- "Red"
print(BirdColor)
BirdColor
BirdColor <- As.factor(BirdColor)
BirdColor
BirdColor <- as.factor(BirdColor)
BirdColor
#organizing the data like this allows for extra power
BirdColor[1]
level(BirdColor)
levels(BirdColor)
levels(BirdColor)[1]
levels(BirdColor)[2]
BirdColor[1] <- "Yellow"
BirdColor <- factor(BirdColor, levels=c(levels(BirdColor), "Yellow"))
BirdColor[1] <- "Yellow"
BirdColor[1]
levels(BirdColor) <- ("Blue Jays", "Robins", "Finches")
levels(BirdColor) <- c("Blue Jays", "Robins", "Finches")
BirdColor
table(as.vector(BirdColor))
table(BirdColor)
Levels(BirdColor)[1] <- "Blue Birds"
BirdColor
levels(BirdColor)[1] <- "Blue Birds"
BirdColor
#Lists are the most flexible data type in R
#Remember the old data types
VectorType <- 1:10
Vectortype
VectorType
MatrixType <- cbind(1:10, 1:10)
MatrixType
DataFrameType <- data.frame(1:10, letters[1:10])
DataFrameType
ListType <- list(VectorType, MatrixType, DataFrameType)
names(ListType) <- c("VectorType", "MatrixType", "DaraDrameType")
ListType
ListType <- c(ListType, list(c("lol random text", "more text")))
ListType
#lists can hold everything
#the tricky part is making your list the way you intend to.
list1 <- list(1:10)
list1
list2 <- as.list(1:10)
list2
list3 <- list(c(1:10, letters[1:10]))
list3
list4 <- list(1:10, letters[1:10])
list4
list5 <- as.list(1:10, letters[1:10])
list5
list6 <- as.list(c(1:10, letters[1:10]))
list6
#pulling data from a list is slightly different too
ListType$VectorType
ListType[[1]]
ListType[1]
class(ListType[[1]])
class(ListType[1])
ListType[1]*2#does not work
ListType[[1]]*2#does work
#Regular Expressions
#Rule 9: Text is flexible
Express <- as.character(MetaData$RecordingDateTime)
Express
#which rows have a given "pattern"
grep("8", Express)#indicies
grepl("8", Express)#Boolean
#Splitting text data
Express2 <- strsplit(Express, " ")
Express2
unlist(Express2)
time <- unlist(Express2)[seq(2,50,by=2)]
time
#changing one set of text for another
sub("0:00", "NULL", time) #first instance only!!!!
sub("0:00", "NULL", Express)
sub("0", "lul", time)
gsub("0", "lul", time)
print("This is a starter sentence.")
paste("This is a starter sentence.")
cat("This is a starter sentence.")
writeLines("This is a starter sentence.")
print("This is a", "starter sentence.")
paste("This is a", "starter sentence.")
cat("This is a", "starter sentence.")
writeLines("This is a", "starter sentence.")
print(c("This is a", "starter sentence."))#broken
paste(c("This is a", "starter sentence."))
cat(c("This is a", "starter sentence."))
writeLines(c("This is a", "starter sentence."))#broken
