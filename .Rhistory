testopenclosed = ace(x=openclosed, phy=openclosedtreenoroot, type="discrete", model="ER")
pdf(paste("openclosedlearningACE2.pdf",sep=""))
plot.phylo(openclosedtreenoroot, cex=0.5)
nodelabels(thermo=testopenclosed$lik.anc, piecol=c("white", "black"), cex=0.3)
tiplabels(pch = 21, bg = co[as.numeric(openclosed)+1], cex = 0.7)
dev.off()
install.packages("meta")
TtoR <-function(t, df) {
sqrt((t^2)/(t^2+df))
}
ZtoR <- function(z,N){
sqrt((z^2)/(z^2+N))
}
Fn1toR <- function(f, dfd){
return(sqrt((f)/(f+dfd)))
}
Fn2toR <- function(f, dfd, dfn){
return(sqrt((dfn*f)/((dfn*f)+dfd)))
}
X21toR <- function(X2, N){
sqrt((X2^2)/N)
}
DtoR <- function(d){
sqrt((d^2)/(4+d^2))
}
ZtoR(2.02, 14)
TtoR <-function(t, df) {
return(sqrt((t^2)/(t^2+df)))
}
ZtoR <- function(z,N){
return(sqrt((z^2)/(z^2+N)))
}
Fn1toR <- function(f, dfd){
return(sqrt((f)/(f+dfd)))
}
Fn2toR <- function(f, dfd, dfn){
return(sqrt((dfn*f)/((dfn*f)+dfd)))
}
X21toR <- function(X2, N){
return(sqrt((X2^2)/N))
}
X21toR <- function(X2, N){
return(sqrt((X2^2)/(X2^2+ N)))
}
DtoR <- function(d){
return(sqrt((d^2)/(4+d^2)))
}
ZtoR(2.02, 14)
ZtoR(2.02, 14)
ZtoR(2.07, 14)
ZtoR(2.07, 9)
ZtoR(-2.7, 10)
DtoR(-.306)
DtoR(-.308)
DtoR(-.246)
TautoR <- function(tau){
return(sin(.5*pi*tau))
}
TautoR(.285)
TautoR(.143)
TautoR(-.331)
TautoR(-.025)
DtoR(-.316)
DtoR(.358)
Fn1toR(5.8, 32)
Fn1toR(3.9, 32)
UtoR <-function(U){
return(1/U)
}
UtoR(29)
UtoR <-function(U, N1, N2){
return((U-((N1*N1)/2))/(sqrt((N1*N2*((N1+N2)+1))/12)))
}
UtoR(29,17,7)
UtoR(2.9,17,7)
UtoR(29,17,7)
n1 <- 17
n2 <- 7
sqrt((N1*N2*(N1+N2+1))/12)
N1 <- 17
N2 <- 7
sqrt((N1*N2*(N1+N2+1))/12)
N1*N2*(N1+N2+1)
(N1*N2*(N1+N2+1))/12)
(N1*N2*(N1+N2+1))/12
sqrt((N1*N2*(N1+N2+1))/12))
sqrt((N1*N2*(N1+N2+1))/12)
(N1*N1)/2)
UtoR <-function(U, N1, N2){
return((U-((N1*N2)/2))/(sqrt((N1*N2*(N1+N2+1))/12)))
}
UtoR(29,17,7)
(N1*N2)/2
29-59.5
-30.5/15.74
UtoR(29,17,7)
UtoZ <-function(U, N1, N2){
return((U-((N1*N2)/2))/(sqrt((N1*N2*(N1+N2+1))/12)))
}
UtoR(29,17,7)
ZtoR(UtoR(29,17,7), (17+7))
ZtoR(-1.685, (17+7))
Fn1toR(3.9, 29)
Fn1toR(5.8, 29)
Fn1toR(3.9, 6)
Fn1toR(3.9, 7)
Fn1toR(6.4, 39)
Fn1toR(6.4, 38)
Fn1toR(9.2, 19)
Fn1toR(5.21, 36)
Fn1toR(6.7, 79)
Fn1toR(6.7, 80)
TtoR(3.209, 13)
TtoR(-.15, 18)
TtoR(-2.21, 18)
X21toR <- function(X2, N){
return(sqrt((X2^2)/N))
}
X22toR <- function(X2, N){
return(sqrt((X2^2)/(X2^2+ N)))
}
X21toR(4.6, 61)
X22toR(4.6, 63)
X22toR(.4, 62)
ZtoR(-1.39, 19
DtoR(.358)
TautoR(-.025)
Fn1toR(6.7, 80)
ZtoR(UtoR(29,17,7), (17+7))
TtoR(-2.21, 18)
UtoZ(29,17,7)
ZtoR(UtoZ(29,17,7), (17+7))
TtoR <-function(t, df) {
return(sqrt((t^2)/(t^2+df)))
}
ZtoR <- function(z,N){
return(sqrt((z^2)/(z^2+N)))
}
Fn1toR <- function(f, dfd){
return(sqrt((f)/(f+dfd)))
}
Fn2toR <- function(f, dfd, dfn){
return(sqrt((dfn*f)/((dfn*f)+dfd)))
}
X21toR <- function(X2, N){
return(sqrt((X2^2)/N))
}
X22toR <- function(X2, N){
return(sqrt((X2^2)/(X2^2+ N)))
}
DtoR <- function(d){
return(sqrt((d^2)/(4+d^2)))
}
TautoR <- function(tau){
return(sin(.5*pi*tau))
}
UtoZ <-function(U, N1, N2){
return((U-((N1*N2)/2))/(sqrt((N1*N2*(N1+N2+1))/12)))
}
ZtoR(-2.7, 10)
DtoR(-.308)
DtoR(-.316)
X21toR(4.6, 72)
X21toR(4.6, 76)
Fn1toR(6.4, 38)
Fn1toR(5.8, 29)
Fn1toR(3.9, 6)
Fn1toR(9.2, 19)
DtoR(.246)
Fn1toR(5.21, 34)
TtoR(3.209, 13)
TautoR(.285)
TautoR(.143)
TautoR(-.331)
TautoR(-.025)
TautoR(.002)
Fn1toR(9.2, 19)
DtoR(-.306)
TtoR(-.4, 6)
ZtoR(2.02, 9)
ZtoR(2.07, 14)
ZtoR(UtoZ(29,17,7), (17+7))
install.packages(c("caTools", "colorspace", "devtools", "digest", "evaluate", "formatR", "gtable", "hexbin", "highr", "htmltools", "httr", "jsonlite", "knitr", "manipulate", "mapproj", "maps", "markdown", "memoise", "mime", "munsell", "plyr", "RColorBrewer", "Rcpp", "RCurl", "reshape2", "rmarkdown", "roxygen2", "rstudioapi", "testthat"))
sessionInfo()
install.packages("phytools")
sessionInfo()
install.packages("phytools")
install.packages("phytools")
sessionInfo()
install.packages("phytools")
package_version(phytools)
rm(list = objects())
rm(list = objects())
#install.packages("maps")
#install.packages("ape")
#install.packages("phytools")
#Libraries
library(maps)
library(ape)
library(phytools)
sessionInfo()
install.packages("phytools")
library(devtools)
install_github("liamrevell/phytools")
install.packages("phytools")
session_info()
library(phytools)
#install.packages("maps")
#install.packages("ape")
#install.packages("phytools")
#Libraries
library(maps)
library(ape)
library(phytools)
session_info()
rm(list = objects())
library(devtools)
install_github("liamrevell/phytools")
nicole [10:29]
library(devtools)
install_github("liamrevell/phytools")
install_github("liamrevell/phytools")
install_github()
sessionInfo()
installed.packages()
install.packages("devtools")
library(devtools)
install_github("liamrevell/phytools")
rm(list = objects())
#install.packages("maps")
#install.packages("ape")
#install.packages("phytools")
#Libraries
library(maps)
library(ape)
library(phytools)
rm(list=objects())
?mean()
getwd()
###########Rule 1: Know where you are. Know where your files are.
getwd()
getwd()
###########Rule 1: Know where you are. Know where your files are.
getwd()
###########Rule 1: Know where you are. Know where your files are.
getwd()
###########Rule 1: Know where you are. Know where your files are.
getwd()
getwd()
dir <- getwd()
print(dir)
rm("dir")
print(dir)
dir <- getwd()
print(dir)
print(dir)
print(dir)
print(dir)
getwd()
rm(dir)
dir <- getwd()
rm("dir")
getwd()
rm("dir")
dir <- getwd()
print(dir)
setwd()
rm("dir")
setwd()
###########Rule 1: Know where you are. Know where your files are.
getwd()
dir <- getwd()
print(dir)
dir
setwd("C:/Users/Kara/Documents/R/BirbClass")
getwd()
setwd("C:/Users/Kara/Documents/")
getwd()
dir
###########Rule 1: Know where you are. Know where your files are.
getwd()
setwd(c(dir, "/R/BirbClass"))
getwd()
c(dir, "/R/BirbClass")
dir
setwd(paste0(dir, "/R/BirbClass"))
###########Rule 1: Know where you are. Know where your files are.
getwd()
#Let's load data.
TestData <- read.table("abigailtestdata.txt", sep = "\t",header = TRUE, fileEncoding = "UTF-8")
###########Rule 2: CaSe MaTtErS! NOSPACES!
#camelcase is standard
print(TestData)
print(testdata)
View(TestData)
View(TestData)
Tes Dat <- "lol"
TesDat <- "lol"
TesDat <- lol
############Rule 3: Indexing is POWER
#let's play with some data
#indexing data from a table
#all rows and cols
print(TestData[,2])
############Rule 3: Indexing is POWER
#let's play with some data
#indexing data from a table
print(TestData[,])#all rows and cols
print(TestData)
print(TestData[,2])
View(TestData)
View(TestData)
print(TestData[,2]); print("lol")
View(TestData)
View(TestData)
AveNoteDur <- TestData[,2]
print(AveNoteDur)
TestData[,"avg_note_duration.ms."]
TestData$avg_note_duration.ms.
#and a forth way
DataIWant <- "avg_note_duration.ms."
TestData[,DataIWant]
DataIWant <- 2
TestData[,DataIWant]
View(TestData)
View(TestData)
TestData[DataIWant,DataIWant]
TestData[2,DataIWant]
DataIWant + DataIWant
mean(DataIWant)
#What about rows?  Same thing, new position.
TestData[1,] #all data for row1
DataIWant <- 3
TestData[2,DataIWant]
TestData[2,DataIWant]
DataIWant <- 2
# want a specific cell?
TestData[1,2]
# want a specific cell?
TestData[2,1]
names(TestData)
View(TestData)
View(TestData)
rownames(TestData)
#what if you only want a subset of TestData?
SubSet <- TestData[,2]
SubSet
is.vector(SubSet) #this will NOT work, wrong dimentions
is.vector(TestData)
is.matrix(Subset) #this WILL work
is.matrix(SubSet) #this WILL work
is.matrix(TestData)
is.data.frame(TestData)
#Why isn't TestData a matrix?
class(SubSet)
class(TesDat)
#let's back up
#Matricies and Vectors have something in common:
#They can only hold one class of data.
SubSetMat <- cbind(SubSet, SubSet)
print(SubSetMat)
class(SubSetMat)
class(SubSetMat[,1])
class(SubSetMat[,2])
letters[1:25]
CharVec <- letters[1:25]
CharVec
NewMat <- cbind(SubSet, CharVec)
class(NewMat)
class(NewMat[,1])
mean(NewMat[,1])
NewMat[,1]
SubSet
NewData <- as.data.frame(SubSet, CharVec)
NewData
NewData <- data.frame(SubSet, CharVec)
NewData
?mean()
??mean
?mean()
??mean
?mean
#What exactly is a function:
#1-a name to call it
#2-Arguments to pass it (optional)
#3-code that does things (optional)
FirstFunstion <- function(){}
#What exactly is a function:
#1-a name to call it
#2-Arguments to pass it (optional)
#3-code that does things (optional)
FirstFunstion <- function()
#What exactly is a function:
#1-a name to call it
#2-Arguments to pass it (optional)
#3-code that does things (optional)
FirstFunstion <- function
#What exactly is a function:
#1-a name to call it
#2-Arguments to pass it (optional)
#3-code that does things (optional)
FirstFunstion <- function(){}
#What exactly is a function:
#1-a name to call it
#2-Arguments to pass it (optional)
#3-code that does things (optional)
FirstFunstion <- function(){}
is.function(FirstFunstion)
#First function is a useless function that does nothing
FirstFunstion <- function(){
print("This is a function!")
}
FirstFunstion()
#now it does something meaningless
#Right now, our function will always do the same thing
#It needs arguments to make custom ouputs
FirstFunstion <- function(x){
print(x)
}
FirstFunstion()
FirstFunstion("lobster")
FirstFunstion(x="lobster")
FirstFunstion("x")
x <- "x"
#now it does something meaningless
#Right now, our function will always do the same thing
#It needs arguments to make custom ouputs
FirstFunstion <- function(x){
print("x")
}
FirstFunstion("lobster")
#now it does something meaningless
#Right now, our function will always do the same thing
#It needs arguments to make custom ouputs
FirstFunstion <- function(x){
print(x)
}
FirstFunstion(x="lobster")
#First function is a useless function that does nothing
FirstFunstion <- function(){
print("This is a function!")
}
FirstFunstion()
#now it does something meaningless
#Right now, our function will always do the same thing
#It needs arguments to make custom ouputs
FirstFunstion <- function(x){
print(x)
}
FirstFunstion()
FirstFunstion <- function(x="crawdad"){
print(x)
}
FirstFunstion()
FirstFunstion("lobster")
FirstFunstion("lobster")
FirstFunstion()
FirstFunstion <- function(x="crawdad", y){
print(x)
if(missing(y)==FALSE){
print(y)
}
}
FirstFunstion()
FirstFunstion("lobster")
FirstFunstion(y="lobster")
#Question 2: (medium)
###A) In how many rows was there more than one unique syllable AND what is the
#average value of these rows?
#HINT: Remember the different ways to index.
greater <- which(TestData$num_unique_syllables > 1)
length(greater)
mean(TestData$num_unique_syllables[greater])
getwd()
dir <- getwd()
print(dir)
setwd("C:/Users/Kara/Documents/R/BirbClass")
getwd()
#Let's load data.
TestData<-read.table("abigailtestdata.txt", sep = '\t',header = TRUE, fileEncoding = "UTF-8")
######
###B) For rows with more than one unique syllable, what were the average
#note durations?  Yes or no, was any average note duration greater than 40ms?
#Hint: you can use the logic inside which() outside of which()
#to make a TRUE/FALSE query
TestData$avg_note_duration.ms.[greater]
length(which(TestData$avg_note_duration.ms. > 40)) >= 1
#Question 1: (easy)
###A) What is the AVERAGE average note duration across all songs?
mean(TestData$avg_note_duration.ms.)
###B) HOW MANY elements/cells/rows are in the first column in TestData?
length(TestData[,1])
###C) WHICH rows in TestData have a number of syllables equal to 39?
#HINT: the documentation is hard to read for this one.  Feel free to Google for examples!
which(TestData$num_syllables == 39)
###D) Make a GRAPH where the independant variable is number of syllables
#and the dependant variable is the bout duration.
plot(TestData$num_syllables,TestData$bout_duration.ms.)
#Question 2: (medium)
###A) In how many rows was there more than one unique syllable AND what is the
#average value of these rows?
#HINT: Remember the different ways to index.
greater <- which(TestData$num_unique_syllables > 1)
length(greater)
mean(TestData$num_unique_syllables[greater])
###B) For rows with more than one unique syllable, what were the average
#note durations?  Yes or no, was any average note duration greater than 40ms?
#Hint: you can use the logic inside which() outside of which()
#to make a TRUE/FALSE query
TestData$avg_note_duration.ms.[greater]
length(which(TestData$avg_note_duration.ms. > 40)) >= 1
TestData$avg_note_duration.ms. > 40
